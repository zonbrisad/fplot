#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# ----------------------------------------------------------------------------
#
#
#
# File:     fplot
# Author:   Peter Malmberg  <peter.malmberg@gmail.com>
# Org:
# Date:     2023-06-12
# License:
# Python:   >= 3.0
#
# ----------------------------------------------------------------------------
from argparse import (
    ArgumentParser,
    FileType,
    RawDescriptionHelpFormatter,
    Action,
)
from copy import copy
import json
import logging
import re
import os
import sys  # We need sys so that we can pass argv to QApplication
import traceback
from dataclasses import dataclass
import math
from typing import Any, Protocol
import psutil
from escape import Ansi, html_to_rgb

try:
    from PyQt6 import QtCore, QtWidgets
    from PyQt6.QtGui import QIcon
except ModuleNotFoundError:
    print("\nPyQt6 not installed.")
    print("\n>sudo apt install python3-pyqt6")
    exit(0)

try:
    import pyqtgraph as pg
except ModuleNotFoundError:
    print("\nPyQtGraph not installed.")
    print("\n>apt install python3-pyqtgraph")
    print("Alternatively, install via pip:")
    print(">pip install pyqtgraph")
    exit(0)


# Absolute path to script itself
self_dir = os.path.abspath(os.path.dirname(sys.argv[0]))
    "AliceBlue": "#F0F8FF",
    "AntiqueWhite": "#FAEBD7",
    "Aqua": "#00FFFF",
    "Aquamarine": "#7FFFD4",
    "Azure": "#F0FFFF",
    "Beige": "#F5F5DC",
    "Bisque": "#FFE4C4",
    "Black": "#000000",
    "BlanchedAlmond": "#FFEBCD",
    "Blue": "#0000FF",
    "BlueViolet": "#8A2BE2",
    "Brown": "#A52A2A",
    "BurlyWood": "#DEB887",
    "CadetBlue": "#5F9EA0",
    "Chartreuse": "#7FFF00",
    "Chocolate": "#D2691E",
    "Coral": "#FF7F50",
    "CornflowerBlue": "#6495ED",
    "Cornsilk": "#FFF8DC",
    "Crimson": "#DC143C",
    "Cyan": "#00FFFF",
    "DarkBlue": "#00008B",
    "DarkCyan": "#008B8B",
    "DarkGoldenRod": "#B8860B",
    "DarkGray": "#A9A9A9",
    "DarkGrey": "#A9A9A9",
    "DarkGreen": "#006400",
    "DarkKhaki": "#BDB76B",
    "DarkMagenta": "#8B008B",
    "DarkOliveGreen": "#556B2F",
    "DarkOrange": "#FF8C00",
    "DarkOrchid": "#9932CC",
    "DarkRed": "#8B0000",
    "DarkSalmon": "#E9967A",
    "DarkSeaGreen": "#8FBC8F",
    "DarkSlateBlue": "#483D8B",
    "DarkSlateGray": "#2F4F4F",
    "DarkSlateGrey": "#2F4F4F",
    "DarkTurquoise": "#00CED1",
    "DarkViolet": "#9400D3",
    "DeepPink": "#FF1493",
    "DeepSkyBlue": "#00BFFF",
    "DimGray": "#696969",
    "DimGrey": "#696969",
    "DodgerBlue": "#1E90FF",
    "FireBrick": "#B22222",
    "FloralWhite": "#FFFAF0",
    "ForestGreen": "#228B22",
    "Fuchsia": "#FF00FF",
    "Gainsboro": "#DCDCDC",
    "GhostWhite": "#F8F8FF",
    "Gold": "#FFD700",
    "GoldenRod": "#DAA520",
    "Gray": "#808080",
    "Grey": "#808080",
    "Green": "#008000",
    "GreenYellow": "#ADFF2F",
    "HoneyDew": "#F0FFF0",
    "HotPink": "#FF69B4",
    "IndianRed": "#CD5C5C",
    "Indigo": "#4B0082",
    "Ivory": "#FFFFF0",
    "Khaki": "#F0E68C",
    "Lavender": "#E6E6FA",
    "LavenderBlush": "#FFF0F5",
    "LawnGreen": "#7CFC00",
    "LemonChiffon": "#FFFACD",
    "LightBlue": "#ADD8E6",
    "LightCoral": "#F08080",
    "LightCyan": "#E0FFFF",
    "LightGoldenRodYellow": "#FAFAD2",
    "LightGray": "#D3D3D3",
    "LightGrey": "#D3D3D3",
    "LightGreen": "#90EE90",
    "LightPink": "#FFB6C1",
    "LightSalmon": "#FFA07A",
    "LightSeaGreen": "#20B2AA",
    "LightSkyBlue": "#87CEFA",
    "LightSlateGray": "#778899",
    "LightSlateGrey": "#778899",
    "LightSteelBlue": "#B0C4DE",
    "LightYellow": "#FFFFE0",
    "Lime": "#00FF00",
    "LimeGreen": "#32CD32",
    "Linen": "#FAF0E6",
    "Magenta": "#FF00FF",
    "Maroon": "#800000",
    "MediumAquaMarine": "#66CDAA",
    "MediumBlue": "#0000CD",
    "MediumOrchid": "#BA55D3",
    "MediumPurple": "#9370DB",
    "MediumSeaGreen": "#3CB371",
    "MediumSlateBlue": "#7B68EE",
    "MediumSpringGreen": "#00FA9A",
    "MediumTurquoise": "#48D1CC",
    "MediumVioletRed": "#C71585",
    "MidnightBlue": "#191970",
    "MintCream": "#F5FFFA",
    "MistyRose": "#FFE4E1",
    "Moccasin": "#FFE4B5",
    "NavajoWhite": "#FFDEAD",
    "Navy": "#000080",
    "OldLace": "#FDF5E6",
    "Olive": "#808000",
    "OliveDrab": "#6B8E23",
    "Orange": "#FFA500",
    "OrangeRed": "#FF4500",
    "Orchid": "#DA70D6",
    "PaleGoldenRod": "#EEE8AA",
    "PaleGreen": "#98FB98",
    "PaleTurquoise": "#AFEEEE",
    "PaleVioletRed": "#DB7093",
    "PapayaWhip": "#FFEFD5",
    "PeachPuff": "#FFDAB9",
    "Peru": "#CD853F",
    "Pink": "#FFC0CB",
    "Plum": "#DDA0DD",
    "PowderBlue": "#B0E0E6",
    "Purple": "#800080",
    "RebeccaPurple": "#663399",
    "Red": "#FF0000",
    "RosyBrown": "#BC8F8F",
    "RoyalBlue": "#4169E1",
    "SaddleBrown": "#8B4513",
    "Salmon": "#FA8072",
    "SandyBrown": "#F4A460",
    "SeaGreen": "#2E8B57",
    "SeaShell": "#FFF5EE",
    "Sienna": "#A0522D",
    "Silver": "#C0C0C0",
    "SkyBlue": "#87CEEB",
    "SlateBlue": "#6A5ACD",
    "SlateGray": "#708090",
    "SlateGrey": "#708090",
    "Snow": "#FFFAFA",
    "SpringGreen": "#00FF7F",
    "SteelBlue": "#4682B4",
    "Tan": "#D2B48C",
    "Teal": "#008080",
    "Thistle": "#D8BFD8",
    "Tomato": "#FF6347",
    "Turquoise": "#40E0D0",
    "Violet": "#EE82EE",
    "Wheat": "#F5DEB3",
    "White": "#FFFFFF",
    "WhiteSmoke": "#F5F5F5",
    "Yellow": "#FFFF00",
    "YellowGreen": "#9ACD32",
}


class App:
    NAME = "fplot"
    VERSION = "0.2"
    DESCRIPTION = "Realtime plot "
    LICENSE = ""
    COPYRIGHT = ""
    AUTHOR = "Peter Malmberg"
    EMAIL = "<peter.malmberg@gmail.com>"
    ORG = ""
    HOME = ""
    ICON = f"{self_dir}/icon/fplot_128x128.png"


class Def:
    DATAPOINTS = 1000
    COLUMNS = 1
    INTERVAL = 1000


class XPlot(Protocol):
    """Plot interface"""

    def update(self) -> None: ...


def get_val(file: str) -> float:
    if os.path.isfile(file):
        with open(file) as file_name:
            data = file_name.read()
            val = float(data)
            logging.debug(f"{file} {val}")
            return val


def rgb2str(r: int, g: int, b: int) -> str:
    return f"#{r:02x}{g:02x}{b:02x}"


PaletteVSCodeL = [
    rgb2str(0, 0, 0),
    rgb2str(205, 49, 49),
    rgb2str(13, 188, 121),
    rgb2str(229, 229, 16),
    rgb2str(36, 114, 200),
    rgb2str(188, 63, 188),
    rgb2str(17, 168, 205),
    rgb2str(229, 229, 229),
    rgb2str(102, 102, 102),
    rgb2str(241, 76, 76),
    rgb2str(35, 209, 139),
    rgb2str(245, 245, 67),
    rgb2str(59, 142, 234),
    rgb2str(214, 112, 214),
    rgb2str(41, 184, 219),
    rgb2str(229, 229, 229),
]

default_plot_color = PaletteVSCodeL[9]
axis_pen = pg.mkPen(color=PaletteVSCodeL[7], width=1)


@dataclass
class PlotParam:
    """Alternative parameter parser, using single letter prefixes"""

    param_string: str = ""
    file_name: str = ""
    title: str = ""
    datapoints: int = 1000
    divider: float = 1
    row: int = 1
    col: int = 1
    average: int = 1
    moving_average: bool = True
    cmd: str = ""
    row_name: str = ""
    pid: int = 0
    process: int = None
    columns: int = 1
    ymin: int = None
    ymax: int = None
    plot_color: str = default_plot_color

    def __post_init__(self) -> None:
        logging.debug(f"PlotParam: {self.param_string}")
        self.parse(self.param_string)

    def start_with(self, param: str, prefix: str) -> bool:
        """Check if param_string starts with prefix"""
        return param.upper().startswith(prefix.upper())

    def parse(self, param_string: str) -> None:
        """Parse parameters from string"""
        self.param_string = param_string
        p = self.param_string.split("#")
        if len(p) > 1:
            self.title = p[1]
            logging.debug(f"Title: {self.title}")

        parameters = p[0].split(":")

        for i, parameter in enumerate(parameters):
            if i == 0:
                self.file_name = parameter
                logging.debug(f"File: {self.file_name}")

            elif self.start_with(parameter, "D"):
                try:
                    self.divider = float(parameter[1:])
                    logging.debug(f"Divider: {self.divider}")
                except ValueError:
                    logging.error(f"Failed to convert {parameter[1:]} to float")

            elif self.start_with(parameter, "PC"):
                self.plot_color = parameter[2:]
                logging.debug(f"Plot color: {self.plot_color}")

            elif self.start_with(parameter, "P"):
                try:
                    self.datapoints = int(parameter[1:])
                    logging.debug(f"Datapoints: {self.datapoints}")
                except ValueError:
                    logging.error(f"Failed to convert {parameter[1:]} to int")

            elif self.start_with(parameter, "MA"):
                self.moving_average = True
                try:
                    self.average = int(parameter[2:])
                    logging.debug(f"Moving average: {self.average}")
                except ValueError:
                    logging.error(f"Failed to convert {parameter[2:]} to int")

            elif self.start_with(parameter, "A"):
                self.moving_average = False
                try:
                    self.average = int(parameter[1:])
                    logging.debug(f"Average: {self.average}")
                except ValueError:
                    logging.error(f"Failed to convert {parameter[1:]} to int")

            elif self.start_with(parameter, "R"):
                try:
                    self.row = int(parameter[1:])
                    logging.debug(f"Row: {self.row}")
                except ValueError:
                    self.row_name = parameter[1:]
                    logging.error(f"Failed to convert {parameter[1:]} to int")
                    if self.title == "":
                        self.title = f"{self.file_name}:{self.row_name}"
            elif self.start_with(parameter, "C"):
                try:
                    self.col = int(parameter[1:])
                    logging.debug(f"Column: {self.col}")
                except ValueError:
                    logging.error(f"Failed to convert {parameter[1:]} to int")
            elif self.start_with(parameter, "YMIN"):
                try:
                    self.ymin = float(parameter[4:])
                    logging.debug(f"Y min: {self.ymin}")
                except ValueError:
                    logging.error(f"Failed to convert {parameter[4:]} to float")
            elif self.start_with(parameter, "YMAX"):
                try:
                    self.ymax = float(parameter[4:])
                    logging.debug(f"Y max: {self.ymax}")
                except ValueError:
                    logging.error(f"Failed to convert {parameter[4:]} to float")


# @dataclass
class AvgFilter:
    """Simple moving average filter"""

    def __init__(self, len: int = 10, moving_average: bool = False) -> None:
        self.len: int = len
        self.data: list[int] = []
        self.moving_average: bool = moving_average

    def update(self, new_val: float) -> float:
        """Update filter with new value"""

        if self.len == 1:
            return new_val

        self.data.append(new_val)
        # self.moving_average = True

        if self.moving_average is True:
            if len(self.data) > self.len:
                self.data.pop(0)
            return sum(self.data) / len(self.data)
        else:
            if len(self.data) >= self.len:
                val = sum(self.data) / len(self.data)
                self.data.clear()
                return val


class SimplePlot:
    def __init__(
        self,
        parent=None,
        params: PlotParam = None,
        source: Any = None,
    ):
        self.params = params
        self.widget = pg.PlotWidget(
            parent=parent,
            background="default",
            plotItem=None,
            title=self.params.title
        )

        self.source = source
        self.last_value = 0
        self.filter = AvgFilter(
            self.params.average,
            self.params.moving_average
        )

        if self.params is not None:
            if self.params.ymin is not None and self.params.ymax is not None:
                self.widget.setYRange(self.params.ymin, self.params.ymax)

        self.x = list(range(self.params.datapoints))
        self.y = [0 for _ in range(self.params.datapoints)]

        pen = pg.mkPen(color=self.params.plot_color, width=1)
        self.line = self.widget.plot(self.x, self.y, pen=pen)

        self.widget.getAxis("bottom").setPen(axis_pen)
        self.widget.getAxis("left").setPen(axis_pen)
        # self.getAxis("right").setPen(plot_pen)
        # self.getAxis("top").setPen(plot_pen)

        # self.setLabel("left", "aaa")
        # self.setLabel("bottom", "bbb")

    def update_plot(self, new_val: float) -> None:
        """Update plot with new value"""

        if new_val is None:
            self.last_value = None
            return

        val = self.filter.update(new_val)

        self.last_value = val

        if val is None:
            return

        self.x = self.x[1:]
        self.x.append(self.x[-1] + 1)
        self.y = self.y[1:]
        self.y.append(val)
        self.line.setData(self.x, self.y)

    def get_widgets(self) -> list[pg.PlotWidget]:
        """Return plot widgets"""
        return [self.widget]


class DerivedPlot(SimplePlot):

    def __init__(self, parent=None, params=None, source=None):
        super().__init__(parent, params)
        self.source = source
        self.params = params

    def update(self) -> None:
        """Update plot with new value"""
        self.update_plot(self.source.last_value)


class Plots:
    def __init__(self):
        self.plots: list[XPlot] = []

    def add_plot(self, plot: XPlot) -> None:
        self.plots.append(plot)

    def update(self) -> None:
        for plot in self.plots:
            plot.update()

    def get_widgets(self) -> list[pg.PlotWidget]:
        """Return plot widgets"""
        widgets = []
        for plot in self.plots:
            widgets.extend(plot.get_widgets())
        return widgets

    def __iter__(self):
        self.index = 0
        return self

    def __next__(self) -> XPlot:
        if self.index >= len(self.plots):
            raise StopIteration
        self.index += 1
        return self.plots[self.index - 1]


class PidPlot(SimplePlot):
    """Plot CPU usage for a specific process"""

    def __init__(
        self,
        params: PlotParam = None,
    ):
        self.params = params
        super().__init__(
            params=params,
        )

    def update(self) -> None:
        """Update plot with new value"""

        if psutil.pid_exists(self.params.pid) is False:
            logging.error(f"PID {self.params.pid} does not exist")
            return

        self.update_plot(self.params.process.cpu_percent())

    def __str__(self) -> str:
        return f"PidPlot {self.params.pid}"


class CPUPlot(SimplePlot):
    """Plot CPU usage"""

    def __init__(
        self,
        params: PlotParam,
    ):
        super().__init__(
            params=params
        )

    def update(self, value=None) -> None:
        """Update plot with new value"""

        if value is None:
            self.update_plot(psutil.cpu_percent(percpu=False))
        else:
            self.update_plot(value)

    def __str__(self) -> str:
        return "CPUPlot"


class CPUPlotI:
    """Plot CPU usage for each core"""

    def __init__(
        self,
        params: PlotParam,
    ):
        self.plots = []
        for x in range(psutil.cpu_count()):
            new_param = copy(params)
            new_param.title = f"CPU{x} (%)"
            self.plots.append(
                CPUPlot(
                    params=new_param
                )
            )

    def update(self) -> None:
        """Update plot with new value"""
        cpu_state = psutil.cpu_percent(percpu=True)

        for i, plot in enumerate(self.plots):
            plot.update(cpu_state[i])

    def get_widgets(self) -> list[pg.PlotWidget]:
        """Return plot widgets"""
        plot_list = []
        for plot in self.plots:
            plot_list.extend(plot.get_widgets())
        return plot_list

    def __str__(self) -> str:
        return "CPUPlot"


class SysPlot(SimplePlot):
    """Plot data from file in /proc or /sys"""

    def __init__(
        self,
        params: PlotParam
    ) -> None:
        super().__init__(
            params=params
        )
        # print(f"Sysplot: {params.file_name} {params.row} {params.col}")
        self.col = params.col
        self.file_name = params.file_name

        if type(params.row) is int:
            self.row = params.row
            return

        if params.row.isnumeric():
            self.row = int(params.row)
        else:
            with open(self.file_name) as file:
                lines = [line for line in file]

            for i, line in enumerate(lines):
                if params.row in line:
                    break
            self.row = i + 1

    def get_line_val(self, row: int, col: int) -> float:
        """Get value from a specific row and column in a file"""

        try:
            with open(self.file_name) as file:
                lines = file.readlines()
        except FileNotFoundError:
            logging.error(f"File not found: {self.file_name}")
            return 0

        line = lines[row - 1].replace("\n", "")
        columns = line.split(" ")

        # Remove empty strings
        columns = [column for column in columns if column != ""]

        try:
            column = columns[col - 1]
            val = float(column) / self.params.divider
            logging.debug(f"{self.file_name} {val} {row} {col}")
        except IndexError:
            logging.error(f'Failed to get column {col} in line: "{line}" {columns}')
            return 0
        except ValueError:  # If value is not a number
            logging.error(f'Failed to convert "{column}" to value, in line: "{line}"')
            val = 0

        return val

    def update(self):
        """Update plot with new value"""

        val = self.get_line_val(self.row, self.col)
        self.update_plot(val)

    def __str__(self) -> str:
        return f"Sysplot {self.file_name} {self.row} {self.col}"


class FilePlot(SimplePlot):
    """Plot data from a ordinary file"""

    def __init__(self, params: PlotParam) -> None:
        super().__init__(
            params=params
        )
        self.params = params
        #logging.debug(f"FilePlot: {params.file_name} {params.col}")
        try:
            self.file = open(self.params.file_name, "r")
        except FileNotFoundError:
            logging.error(f"File not found: {self.params.file_name}")
            self.file = None

    def get_line_val(self, col: int) -> float:
        """Get value from a specific row and column in a file"""

        if self.file is None:
            print("File is None")
            return None

        try:
            line = self.file.readline()
        except FileNotFoundError:
            logging.error(f"File not found: {self.params.file_name}")
            return None
        except ValueError:
            return None

        if line == "":
            self.file.close()
            return None

        columns = line.split(" ")
        # Remove empty strings
        columns = [column for column in columns if column != ""]
        try:
            column = columns[col - 1]
            val = float(column) / self.params.divider
            logging.debug(f"{self.params.file_name} {val} {self.params.col}")
            #print("Value:", val)
        except IndexError:
            logging.error(f'Failed to get column {col} in line: "{line}" {columns}')
            val = 0
            print("IndexError")
        except ValueError:  # If value is not a number
            logging.error(f'Failed to convert "{column}" to value, in line: "{line}"')
            val = None
            print("ValueError")
        return val

    def update(self) -> None:
        """Update plot with new value"""

        val = self.get_line_val(self.params.col)
        self.update_plot(val)

    def __str__(self) -> str:
        return f"FilePlot {self.params.file_name} {self.params.row} {self.params.col}"


class ProcessPlot(SimplePlot):
    """Plot data from a process"""

    def __init__(
        self,
        file_name: str = "",
        cmd: str = "",
        row: str = "1",
        col: int = 0,
        row_name: str = "",
        title: str = "",
        datapoints: int = 1000,
        divider=1,
        average=1,
    ) -> None:
        super().__init__(
            title=title, datapoints=datapoints, average=average, divider=divider
        )

        self.col = col
        self.file_name = file_name
        self.cmd = cmd

        self.process = QtCore.QProcess()

    def update(self):
        """Update plot with new value"""

        self.process.start(self.cmd)
        self.process.waitForFinished()
        data = self.process.readAll()

        lines = str(data, "utf-8").split("\n")
        line = lines[self.row - 1]
        columns = re.split(r" |\t", line)
        # remove empty strings
        columns = [x for x in columns if x != ""]
        column = columns[self.col - 1]

        try:
            val = float(column) / self.divider
            logging.debug(f"Exec: {self.cmd}  {self.col} {self.row}")
        except ValueError:
            logging.error(f'Failed to convert "{column}" to value, in line: "{line}"')
            val = 0

        self.update_plot(val)

    def __str__(self) -> str:
        return f"FilePlot {self.file_name} {self.row} {self.col}"


class MainWindow(QtWidgets.QMainWindow):
    """Main window for fplot"""

    def __init__(
        self,
        plotwidgets: Plots,
        title: str = "",
        columns: int = 1,
        interval: int = 1000,
    ):
        super(MainWindow, self).__init__()

        self.plots = plotwidgets
        self.setWindowTitle(title)
        self.setWindowIcon(QIcon(App.ICON))
        centralWidget = QtWidgets.QWidget(self)
        self.setCentralWidget(centralWidget)
        self.vbox = QtWidgets.QVBoxLayout(centralWidget)
        self.vbox.setContentsMargins(0, 0, 0, 0)

        # hbox = QtWidgets.QHBoxLayout(centralWidget)
        hbox = QtWidgets.QHBoxLayout()
        hbox.setSpacing(0)
        hbox.setContentsMargins(0, 0, 0, 0)
        self.vbox.addLayout(hbox)

        # button = QPushButton("Quit", self)
        # self.vbox.addWidget(button)
        # self.graphWidget.setBackground('w')

        vboxes: list[QtWidgets.QHBoxLayout] = []
        for i in range(columns):
            vbox = QtWidgets.QVBoxLayout()
            vbox.setSpacing(0)
            hbox.addLayout(vbox)
            vboxes.append(vbox)

        plotwidgets = self.plots.get_widgets()
        per = math.ceil(len(plotwidgets) / columns)
        for i, widget in enumerate(plotwidgets):
            vboxes[i // per].addWidget(widget)

        self.timer = QtCore.QTimer()
        self.timer.setInterval(interval)
        self.timer.timeout.connect(self.update_plot_data)
        self.timer.start()

    def update_plot_data(self):
        self.plots.update()


class FConf(PlotParam):
    """Parse JSON config file"""

    def __init__(
        self, file_name: str, title: str = "", datapoints: int = 1000, columns: int = 1
    ) -> None:
        super().__init__()
        self.file_name = file_name
        self.conf = {}

        with self.file_name as infile:
            self.conf = json.load(infile)

        self.title = self.get_param("title", title)
        self.datapoints = self.get_param("datapoints", datapoints)
        self.columns = self.get_param("columns", columns)
        self.average = self.get_param("average", 1)

        self.params = []
        for plotd in self.conf["plots"]:
            params = PlotParam(
                param_string="",
                file_name=self.get_param_conf(plotd, "file", ""),
                cmd=self.get_param_conf(plotd, "cmd", ""),
                title=self.get_param_conf(plotd, "title", ""),
                divider=self.get_param_conf(plotd, "divider", self.divider),
                row=self.get_param_conf(plotd, "row", 1),
                col=self.get_param_conf(plotd, "col", 1),
                # datapoints=self.get_param_conf(plotd,"datapoints", datapoints),
                # average=self.get_param_conf(plotd,"average", args.average),
            )
            self.params.append(params)

    def get_param(self, param: str, default: Any) -> Any:
        """Get parameter from config file"""

        if param in self.conf:
            return self.conf[param]

        return default

    def get_param_conf(self, conf: dict, param: str, default: Any) -> Any:
        """Get parameter from config file"""
        if param in conf:
            return conf[param]

        return default


app = QtWidgets.QApplication(sys.argv)

params_order = []
plot_list = Plots()


class CustomAction(Action):
    """Custom action for argparse"""

    def __init__(self, option_strings, dest, **kwargs):
        super().__init__(option_strings, dest, **kwargs)

    def __call__(self, parser, namespace, values, option_string=None):
        params = PlotParam(
            param_string=values,
            datapoints=namespace.datapoints,
            average=namespace.average
        )

        if self.dest == "plot":
            plot_list.add_plot(SysPlot(params=params))

        elif self.dest == "plotf":
            plot_list.add_plot(FilePlot(params=params))

        elif self.dest == "plotd":
            try:
                src_idx = params.file_name.count('.')
                source = plot_list.plots[0 - src_idx]
            except IndexError:
                logging.error(f"Failed to get source plot for derived plot: {params.file_name}")
                return

            params = copy(source.params)
            params.parse(values)
            plot = DerivedPlot(params=params, source=source)
            plot_list.add_plot(plot)

        elif self.dest == "plotcpu":
            params.title = "CPU (%)"
            params.ymin = 0
            params.ymax = 100
            plot_list.add_plot(
                CPUPlot(params=params)
            )

        logging.debug(f"Dest: {self.dest} Values: {values}")
        dest = getattr(namespace, self.dest)
        params_order.append(params)
        setattr(namespace, self.dest, dest)


epilog = """

src:params#"My title"

Plot parameters:
  src     Filename or pid number of process to plot
  Dxx     Set divisor, with wich to divide the datavalues
  Pxx     Set number of datapoints in plot
  Axx     Add an averaging filter, XX = points
  Mxx     Add a moving average filter, XX = points
  Rxx     Row in file
  Cxx     Column in file
  YMIN    Minimum Y axis value
  YMAX    Maximum Y axis value
  #TITLE  Title text of plot


Examples:\n

> fplot --plot /sys/class/hwmon/hwmon0/temp1_input:d1000#"CPU Temp"
> fplot --plot /proc/meminfo:r2:c2:d1024#"Free Memory (MB)"
> fplot --plotpid 1234#"Process CPU time (%)"
> fplot --plotcpu#"Total CPU (%)"
"""


def main() -> None:
    logging_format = "[%(levelname)s] %(lineno)d %(funcName)s() : %(message)s"
    #logging.basicConfig(format=logging_format, level=logging.DEBUG)
    parser = ArgumentParser(
        prog=App.NAME,
        description=App.DESCRIPTION,
        epilog=epilog,
        add_help=True,
        formatter_class=RawDescriptionHelpFormatter,
    )
    parser.add_argument(
        "--plot",
        action=CustomAction,
        default=[],
        help="Add plot from file in /proc or /sys",
        metavar="",
    )
    parser.add_argument(
        "--plotf",
        action=CustomAction,
        default=[],
        help="Add plot from a regular file, reading sequentially",
        metavar="",
    )
    parser.add_argument(
        "--plotpid",
        action=CustomAction,
        default=[],
        help="Add plot for a specific PID",
        metavar="PID",
    )
    parser.add_argument(
        "--plotcpu",
        action=CustomAction,
        default="x",
        help="Add plot for total CPU usage",
    )
    # parser.add_argument(
    #     "--plotcpui",
    #     action="store_true",
    #     default=[],
    #     help="Add CPU usage plot, all individual cores",
    # )
    parser.add_argument(
        "--plotd",
        action=CustomAction,
        default=[],
        help="Add a plot.",
        metavar="",
    )
    parser.add_argument(
        "--columns",
        action="store",
        default=Def.COLUMNS,
        type=int,
        help="Set number of columns",
        metavar="N",
    )
    parser.add_argument(
        "--datapoints",
        default=Def.DATAPOINTS,
        type=int,
        help="Set default nr of datapoints",
        metavar="N",
    )
    parser.add_argument(
        "--average",
        default=1,
        type=int,
        help="Set moving average filter",
        metavar="N",
    )
    parser.add_argument(
        "--interval",
        default=Def.INTERVAL,
        type=int,
        help="Set update interval (ms)",
        metavar="N",
    )
    parser.add_argument(
        "--title",
        default="",
        type=str,
        help="Set window title"
    )
    parser.add_argument(
        "--conf",
        action="append",
        default=[],
        type=FileType("r"),
        help="Fplot config file",
        metavar="FILE",
    )
    parser.add_argument(
        "--debug",
        action="store_true",
        default=False,
        help="Print debug messages"
    )
    parser.add_argument(
        "--colors",
        action="store_true",
        default=False,
        help="Print available colors"
    )
    parser.add_argument(
        "--version",
        action="version",
        version=f"{App.NAME} {App.VERSION}",
        help="Print version information",
    )
    args = parser.parse_args()

    if args.debug:
        logging.basicConfig(format=logging_format, level=logging.DEBUG)
    else:
        logging.basicConfig(format=logging_format)

    # app = QtWidgets.QApplication(sys.argv)

    # Handle plot setup files
    for config_file in args.conf:

        config = FConf(
            file_name=config_file,
            title=args.title,
            datapoints=args.datapoints,
            columns=args.columns,
        )

        for params in config.params:
            if params.file_name == "cpu":
                cpu_plot = CPUPlot(
                    title=params.title,
                    datapoints=params.datapoints,
                    average=params.average,
                )
                plot_list.add_plot(cpu_plot)
                continue

            if params.file_name == "cpui":
                cpu_plot = CPUPlotI(
                    datapoints=params.datapoints,
                    average=params.average,
                )
                plot_list.add_plot(cpu_plot)
                continue

            file_plot = SysPlot(params=params)
            logging.debug(file_plot)
            plot_list.add_plot(file_plot)

    for params in args.plotpid:
        params.ymin = 0
        params.ymax = 100

        try:
            params.pid = int(params.file_name)
        except ValueError:
            logging.error(f"Invalid PID: {params.file_name}")
            continue
        params.process = psutil.Process(params.pid)

        params.title = f'pid {params.pid} "{params.process.name()}" (%)'
        if psutil.pid_exists(params.pid) is False:
            logging.error(f"PID {params.pid} does not exist")
            continue
        plot_list.add_plot(
            PidPlot(params=params)
        )

    # for proc in args.process:
    #     process = QtCore.QProcess()
    #     process.start(proc)
    #     pid_plot = PidPlot(
    #         pid=process.processId(), datapoints=args.datapoints, average=args.average
    #     )
    #     plots.append(pid_plot)
    #     file_plot = FilePlot(
    #         file_name=f"/proc/{process.processId()}/stat",
    #         title="Memory usage",
    #         divider=1024 * 1024,
    #         # datapoints=datapoints,
    #         row="1",
    #         col=23,
    #         # average=average,
    #     )
    #     plots.append(file_plot)


    # if args.plotcpui:
    #     params = PlotParam(
    #         title="CPU (%)",
    #         datapoints=args.datapoints,
    #         average=args.average,
    #         ymin=0,
    #         ymax=100,
    #     )
    #     plot_list.add_plot(
    #         CPUPlotI(
    #             params=params
    #         )
    #     )

    if args.colors:
        print("Html colors:")
        htb = list(html_to_rgb.items())
        for x in range(0, len(htb)//4):
            color1, hex_value1 = htb[x]
            r1, g1, b1 = hex_value1
            print(f"{color1:21} {Ansi.bg_24bit_color(r1, g1, b1)}       {Ansi.RESET}  ", end="")

            color2, hex_value2 = htb[x + 37]
            r2, g2, b2 = hex_value2
            print(f"{color2:21} {Ansi.bg_24bit_color(r2, g2, b2)}       {Ansi.RESET}  ", end="")

            color3, hex_value3 = htb[x + 74]
            r3, g3, b3 = hex_value3
            print(f"{color3:21} {Ansi.bg_24bit_color(r3, g3, b3)}       {Ansi.RESET}  ", end="")

            color4, hex_value4 = htb[x + 111]
            r4, g4, b4 = hex_value4
            print(f"{color4:21} {Ansi.bg_24bit_color(r4, g4, b4)}       {Ansi.RESET}")

        return 0
    
    if len(plot_list.plots) == 0:
        parser.print_help()
        return 1

    for plotarg in plot_list.plots:
        logging.debug(plotarg)

    if "config" in locals():
        main = MainWindow(
            plot_list,
            title=config.title,
            columns=config.columns,
            interval=config.interval,
        )
    else:
        main = MainWindow(
            plot_list, title=args.title, columns=args.columns, interval=args.interval
        )
    main.show()
    sys.exit(app.exec())


if __name__ == "__main__":
    try:
        main()
        sys.exit(0)
    except KeyboardInterrupt as e:  # Ctrl-C
        raise e
    except SystemExit as e:  # sys.exit()
        raise e
    except Exception as e:
        logging.error("UNEXPECTED EXCEPTION")
        logging.error(str(e))
        traceback.print_exc()
        os._exit(1)
