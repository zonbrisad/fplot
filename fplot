#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# ----------------------------------------------------------------------------
#
#
#
# File:     fplot
# Author:   Peter Malmberg  <peter.malmberg@gmail.com>
# Org:
# Date:     2023-06-12
# License:
# Python:   >= 3.0
#
# ----------------------------------------------------------------------------
import argparse
import json
import logging
import re
import os
import sys  # We need sys so that we can pass argv to QApplication
import traceback
from dataclasses import dataclass
from enum import Enum
import math

import pyqtgraph as pg
from PyQt5 import QtCore, QtWidgets
from pyqtgraph import PlotWidget


class App:
    NAME = "fplot"
    VERSION = "0.2"
    DESCRIPTION = "Realtime plot "
    LICENSE = ""
    COPYRIGHT = ""
    AUTHOR = "Peter Malmberg"
    EMAIL = "<peter.malmberg@gmail.com>"
    ORG = ""
    HOME = ""
    ICON = ""
    # defaults
    DATAPOINTS = 1000
    COLUMNS = 1
    INTERVAL = 1


class Def:
    DATAPOINTS = 1000
    COLUMNS = 1
    INTERVAL = 1000


def get_val(file: str) -> float:
    if os.path.isfile(file):
        with open(file) as file_name:
            data = file_name.read()
            val = float(data)
            logging.debug(f"{file} {val}")
            return val


class PlotType(Enum):
    Normal = 0
    RC = 1
    RC_Str = 2
    Exec = 3


pen = pg.mkPen(color=(255, 0, 100), width=1)


@dataclass
class FPid:
    pid: int = 0
    first_run: bool = True
    utime: int = 0
    stime: int = 0
    old_utime: int = 0
    old_stime: int = 0
    start_time: int = 0
    old_start_time: int = 0
    datapoints: int = App.DATAPOINTS
    clk_tck: int = 100

    def __post_init__(self):
        self.gw_utime = pg.PlotWidget()
        self.gw_utime.setTitle(f"pid {self.pid}")
        # self.gw_utime.setTitle(self.title)

        self.x = list(range(self.datapoints))
        self.y = [0 for _ in range(self.datapoints)]
        self.line = self.gw_utime.plot(self.x, self.y, pen=pen)

        process = QtCore.QProcess()
        process.start("getconf CLK_TCK")
        process.waitForFinished()
        data = process.readAll()
        line = str(data, "utf-8")
        self.clk_tck = int(line)
        # print(self.clk_tck)

    def update(self):
        with open(f"/proc/{self.pid}/stat") as file:
            line = file.read()

        line_s = line.split(" ")

        self.old_utime = self.utime
        self.old_stime = self.stime
        self.old_start_time = self.start_time

        # https://www.baeldung.com/linux/total-process-cpu-usage

        # scheduled user mode time in clock ticks
        self.utime = int(line_s[13]) / self.clk_tck
        # scheduled kernel mode time in clock ticks
        self.stime = int(line_s[14]) / self.clk_tck
        self.start_time = int(line_s[21]) / self.clk_tck  #

        if self.first_run is True:
            self.old_utime = self.utime
            self.old_stime = self.stime
            self.old_start_time = self.start_time
            self.first_run = False

        val = (self.utime + self.stime - self.old_utime - self.old_stime) * 100
        logging.debug(line_s)

        self.x = self.x[1:]
        self.x.append(self.x[-1] + 1)
        self.y = self.y[1:]
        self.y.append(val)
        self.line.setData(self.x, self.y)


@dataclass
class AvgFilter:
    len: int = 10

    def __post_init__(self):
        self.data = []

    def update(self, new_val: float) -> float:
        self.data.append(new_val)
        if len(self.data) > self.len:
            self.data.pop(0)

        return sum(self.data) / len(self.data)


@dataclass
class FPlot:
    type: PlotType = PlotType.Normal
    cmd: str = ""
    file_name: str = ""
    datapoints: int = 1000
    title: str = ""
    divider: float = 1
    row: str = "1"
    col: int = 0
    row_name: str = ""
    average: int = 1

    def __post_init__(self):
        self.filter = AvgFilter(self.average)

        self.gw = pg.PlotWidget()
        self.gw.setTitle(self.title)

        self.x = list(range(self.datapoints))
        self.y = [0 for _ in range(self.datapoints)]
        self.line = self.gw.plot(self.x, self.y, pen=pen)
        self.process = QtCore.QProcess()

        if self.row.isnumeric():
            self.row = int(self.row)
        else:
            # title = f"{self.file_name}:{row_name}"
            with open(self.file_name) as file:
                lines = [line for line in file]

            for i, line in enumerate(lines):
                if self.row in line:
                    break
            self.row = i + 1

    def get_line_val(self, row: int, col: int) -> float:
        if os.path.isfile(self.file_name):
            with open(self.file_name) as file:
                lines = file.readlines()
            line = lines[row - 1]
            d = line.split(" ")
            data = [x for x in d if x != ""]  # Remove empty strings
            logging.debug(data)
            # print(f"{col} {self.col} {data}")
            val = float(data[col - 1])
            logging.debug(f"{self.file_name} {val} {row} {col}")
            return val

    def update(self):
        if self.cmd != "":
            self.process.start(self.cmd)
            self.process.waitForFinished()
            data = self.process.readAll()

            lines = str(data, "utf-8").split("\n")
            columns = re.split(r" |\t", lines[self.row - 1])
            columns_c = [x for x in columns if x != ""]
            logging.debug(f"{self.col}  {self.row}")
            logging.debug(f"{columns_c}")
            new_val = float(columns_c[self.col - 1]) / self.divider
        else:
            new_val = self.get_line_val(self.row, self.col) / self.divider

        val = self.filter.update(new_val)

        self.x = self.x[1:]
        self.x.append(self.x[-1] + 1)
        self.y = self.y[1:]
        self.y.append(val)
        self.line.setData(self.x, self.y)


def get_param(conf, param, default):
    if param in conf:
        return conf[param]
    else:
        return default


class MainWindow(QtWidgets.QMainWindow):
    def __init__(self, plots, fpids, args):
        super(MainWindow, self).__init__()

        self.plots = plots
        self.fpids = fpids
        self.setWindowTitle(args.title)
        # self.setWindowTitle(App.NAME)
        centralWidget = QtWidgets.QWidget(self)
        self.setCentralWidget(centralWidget)
        hbox = QtWidgets.QHBoxLayout(centralWidget)
        hbox.setSpacing(0)
        hbox.setContentsMargins(1, 1, 1, 1)

        # self.graphWidget.setBackground('w')
        vboxes = []
        for i in range(args.columns):
            vbox = QtWidgets.QVBoxLayout()
            vbox.setSpacing(0)
            hbox.addLayout(vbox)
            vboxes.append(vbox)

        per = math.ceil((len(self.plots) + len(self.fpids)) / args.columns)
        for i, pl in enumerate(self.plots):
            vboxes[i // per].addWidget(pl.gw)

        for i, fpid in enumerate(self.fpids):
            vboxes[i // per].addWidget(fpid.gw_utime)

        self.timer = QtCore.QTimer()
        self.timer.setInterval(1000)
        self.timer.timeout.connect(self.update_plot_data)
        self.timer.start()

    def update_plot_data(self):
        for plot in self.plots:
            plot.update()

        for fpid in self.fpids:
            fpid.update()


def get_pos_arg_str(lst, i, default) -> str:
    if i < len(lst):
        return lst[i]
    else:
        return default


def get_pos_arg_float(lst, i, default) -> float:
    if i < len(lst):
        return float(lst[i])
    else:
        return default


def get_pos_arg_int(lst, i, default) -> int:
    if i < len(lst):
        return int(lst[i])
    else:
        return default


class Params:
    def __init__(self, param_string: str):
        self.params = param_string.split(":")

    def get_str(self, i, default):
        pass
        # params = p.split(":")
        # file_name = get_pos_arg_str(params, 0, "")
        # divider = get_pos_arg_float(params, 1, 1)


def get_param(conf, param, default):
    if param in conf:
        return conf[param]

    return default


def main() -> None:
    logging_format = "[%(levelname)s] %(lineno)d %(funcName)s() : %(message)s"

    parser = argparse.ArgumentParser(
        prog=App.NAME, description=App.DESCRIPTION, epilog="", add_help=True
    )
    parser.add_argument("--plot", action="append", default=[], help="Add another plot")
    parser.add_argument(
        "--plotrc", action="append", default=[], help="Add another plot row column"
    )
    parser.add_argument(
        "--plotexec",
        action="append",
        default=[],
        help="Add another plot via external command",
    )
    parser.add_argument(
        "--pid",
        action="append",
        default=[],
        help="Add pid plot",
    )
    parser.add_argument(
        "--columns",
        action="store",
        default=Def.COLUMNS,
        type=int,
        help="Set number of columns",
    )
    parser.add_argument(
        "--datapoints",
        default=Def.DATAPOINTS,
        type=int,
        help="Set default nr of datapoints",
    )
    parser.add_argument(
        "--average",
        default=1,
        type=int,
        help="Set moving average filter",
    )
    parser.add_argument(
        "--interval", default=Def.INTERVAL, type=int, help="Set update interval (ms)"
    )
    parser.add_argument("--title", default="", type=str, help="Set window title")
    parser.add_argument(
        "--conf",
        action="append",
        default=[],
        type=argparse.FileType("r"),
        help="Fplot config file",
    )
    parser.add_argument(
        "--debug", action="store_true", default=False, help="Print debug messages"
    )
    parser.add_argument(
        "--version",
        action="version",
        version=f"{App.NAME} {App.VERSION}",
        help="Print version information",
    )
    args = parser.parse_args()
    # parser.print_help()
    # print(args)

    if args.debug:
        logging.basicConfig(format=logging_format, level=logging.DEBUG)

    app = QtWidgets.QApplication(sys.argv)
    plots = []

    for p in args.plot:
        params = p.split(":")
        file_name = get_pos_arg_str(params, 0, "")
        divider = get_pos_arg_float(params, 1, 1)
        dp = get_pos_arg_int(params, 2, args.datapoints)
        average = get_pos_arg_int(params, 3, args.average)
        fplot = FPlot(
            type=PlotType.Normal,
            file_name=file_name,
            title=file_name,
            divider=divider,
            datapoints=dp,
            row="1",
            col=1,
            average=average,
        )
        logging.debug(fplot)
        plots.append(fplot)

    for p in args.plotrc:
        params = p.split(":")
        file_name = get_pos_arg_str(params, 0, "")

        try:
            row = get_pos_arg_int(params, 1, 1)
            title = f"{file_name}:{row}"
            pt = PlotType.RC
        except ValueError:
            pt = PlotType.RC_Str
            row_name = get_pos_arg_str(params, 1, "")
            title = f"{file_name}:{row_name}"
            with open(file_name) as file:
                lines = [line for line in file]

            for i, line in enumerate(lines):
                if row_name in line:
                    break
            row = i + 1
            logging.debug(f"Row {row}")

        col = get_pos_arg_int(params, 2, 1)
        divider = get_pos_arg_float(params, 3, 1)
        datapoints = get_pos_arg_int(params, 4, args.datapoints)
        average = get_pos_arg_int(params, 5, args.average)

        fplot = FPlot(
            type=pt,
            file_name=file_name,
            title=title,
            divider=divider,
            datapoints=datapoints,
            row=row,
            col=col,
            average=average,
        )

        plots.append(fplot)
        logging.debug(fplot)

    for p in args.plotexec:
        params = p.split(":")
        cmd = get_pos_arg_str(params, 0, "")
        row = get_pos_arg_int(params, 1, 1)
        col = get_pos_arg_int(params, 2, 1)
        divider = get_pos_arg_float(params, 3, 1)
        datapoints = get_pos_arg_int(params, 4, args.datapoints)
        average = get_pos_arg_int(params, 5, args.average)

        title = f"{cmd} {row} {col}"
        fplot = FPlot(
            type=PlotType.Exec,
            cmd=cmd,
            title=title,
            divider=divider,
            datapoints=datapoints,
            row=row,
            col=col,
            average=average,
        )
        plots.append(fplot)
        logging.debug(fplot)

    # Handle plot setup files
    for c in args.conf:
        with c as infile:
            conf = json.load(infile)

        if args.title == "":
            args.title = get_param(conf, "title", "")

        if args.columns == 1:
            args.columns = get_param(conf, "columns", 1)

        pl = conf["plots"]
        for p in pl:
            fplot = FPlot(
                type=PlotType.Normal,
                file_name=p["file"],
                cmd=p["cmd"],
                title=p["title"],
                divider=p["divider"],
                datapoints=p["datapoints"],
                row=p["row"],
                col=p["col"],
                average=get_param(p, "average", args.average),
            )
            logging.debug(fplot)
            plots.append(fplot)

    fpids = []
    for pid in args.pid:
        fpid = FPid(pid=pid, datapoints=args.datapoints)
        fpids.append(fpid)

    main = MainWindow(plots, fpids, args)
    main.show()
    sys.exit(app.exec_())


if __name__ == "__main__":
    try:
        main()
        sys.exit(0)
    except KeyboardInterrupt as e:  # Ctrl-C
        raise e
    except SystemExit as e:  # sys.exit()
        raise e
    except Exception as e:
        print("ERROR, UNEXPECTED EXCEPTION")
        print(str(e))
        traceback.print_exc()
        os._exit(1)
