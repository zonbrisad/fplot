#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# ----------------------------------------------------------------------------
#
#
#
# File:     fplot
# Author:   Peter Malmberg  <peter.malmberg@gmail.com>
# Org:
# Date:     2023-06-12
# License:
# Python:   >= 3.0
#
# ----------------------------------------------------------------------------
from argparse import (
    ArgumentParser,
    FileType,
    RawDescriptionHelpFormatter,
    Action,
)
from copy import copy
import time
import json
import logging
import re
import os
import sys  # We need sys so that we can pass argv to QApplication
import traceback
from dataclasses import dataclass
import math
from typing import Any, Protocol
import psutil
from escape import Ansi, print_html_colors

try:
    from PyQt6 import QtCore, QtWidgets
    from PyQt6.QtGui import QIcon
    from PyQt6.QtWidgets import QPushButton, QHBoxLayout
except ModuleNotFoundError:
    print("\nPyQt6 not installed.")
    print("\n>sudo apt install python3-pyqt6")
    exit(0)

try:
    import pyqtgraph as pg
except ModuleNotFoundError:
    print("\nPyQtGraph not installed.")
    print("\n>apt install python3-pyqtgraph")
    print("Alternatively, install via pip:")
    print(">pip install pyqtgraph")
    exit(0)

try:
    import RPi.GPIO as GPIO
except ImportError:
    #print("RPi.GPIO not available, running in simulation mode.")
    GPIO = False



# Absolute path to script itself
self_dir = os.path.abspath(os.path.dirname(sys.argv[0]))

plot_args_list = []


def contains_only(char, s):
    return s == char * len(s)


class App:
    NAME = "fplot"
    VERSION = "0.2"
    DESCRIPTION = "Realtime plot "
    LICENSE = ""
    COPYRIGHT = ""
    AUTHOR = "Peter Malmberg"
    EMAIL = "<peter.malmberg@gmail.com>"
    ORG = ""
    HOME = ""
    ICON = f"{self_dir}/icon/fplot2_128x128.png"


class Def:
    DATAPOINTS = 1000
    COLUMNS = 1
    INTERVAL = 1000


class XPlot(Protocol):
    """Plot interface"""

    def update(self) -> None: ...


def get_val(file: str) -> float:
    if os.path.isfile(file):
        with open(file) as file_name:
            data = file_name.read()
            val = float(data)
            logging.debug(f"{file} {val}")
            return val


def rgb2str(r: int, g: int, b: int) -> str:
    return f"#{r:02x}{g:02x}{b:02x}"


PaletteVSCodeL = [
    rgb2str(0, 0, 0),
    rgb2str(205, 49, 49),
    rgb2str(13, 188, 121),
    rgb2str(229, 229, 16),
    rgb2str(36, 114, 200),
    rgb2str(188, 63, 188),
    rgb2str(17, 168, 205),
    rgb2str(229, 229, 229),
    rgb2str(102, 102, 102),
    rgb2str(241, 76, 76),
    rgb2str(35, 209, 139),
    rgb2str(245, 245, 67),
    rgb2str(59, 142, 234),
    rgb2str(214, 112, 214),
    rgb2str(41, 184, 219),
    rgb2str(229, 229, 229),
]

default_plot_color = PaletteVSCodeL[9]
axis_pen = pg.mkPen(color=PaletteVSCodeL[7], width=1)


@dataclass
class PlotParam:
    """Alternative parameter parser, using single letter prefixes"""

    param_string: str = ""
    file_name: str = ""
    title: str = ""
    datapoints: int = 1000
    divider: float = 1
    row: int = 1
    col: int = 1
    average: int = 1
    moving_average: bool = True
    cmd: str = ""
    row_name: str = ""
    pid: int = 0
    process: int = None
    columns: int = 1
    ymin: int = None
    ymax: int = None
    plot_color: str = default_plot_color
    grid: bool = False
    x_axis_time: bool = True
    interval: int = 1000

    def __post_init__(self) -> None:
        logging.debug(f"PlotParam: {self.param_string}")
        if self.param_string != "":
            self.parse(self.param_string)

    def start_with(self, param: str, prefix: str) -> bool:
        """Check if param_string starts with prefix"""
        return param.upper().startswith(prefix.upper())

    def parse(self, param_string: str) -> None:
        """Parse parameters from string"""
        self.param_string = param_string
        p = self.param_string.split("#")
        if len(p) > 1:
            self.title = p[1]
            logging.debug(f"Title: {self.title}")

        parameters = p[0].split(":")

        for i, parameter in enumerate(parameters):
            if i == 0:
                self.file_name = parameter
                logging.debug(f"File: {self.file_name}")

            elif self.start_with(parameter, "D"):
                try:
                    self.divider = float(parameter[1:])
                    logging.debug(f"Divider: {self.divider}")
                except ValueError:
                    logging.error(f"Failed to convert {parameter[1:]} to float")

            elif self.start_with(parameter, "PC"):
                self.plot_color = parameter[2:]
                logging.debug(f"Plot color: {self.plot_color}")

            elif self.start_with(parameter, "P"):
                try:
                    self.datapoints = int(parameter[1:])
                    logging.debug(f"Datapoints: {self.datapoints}")
                except ValueError:
                    logging.error(f"Failed to convert {parameter[1:]} to int")

            elif self.start_with(parameter, "MA"):
                self.moving_average = True
                try:
                    self.average = int(parameter[2:])
                    logging.debug(f"Moving average: {self.average}")
                except ValueError:
                    logging.error(f"Failed to convert {parameter[2:]} to int")

            elif self.start_with(parameter, "A"):
                self.moving_average = False
                try:
                    self.average = int(parameter[1:])
                    logging.debug(f"Average: {self.average}")
                except ValueError:
                    logging.error(f"Failed to convert {parameter[1:]} to int")

            elif self.start_with(parameter, "R"):
                try:
                    self.row = int(parameter[1:])
                    logging.debug(f"Row: {self.row}")
                except ValueError:
                    self.row_name = parameter[1:]
                    logging.error(f"Failed to convert {parameter[1:]} to int")
                    if self.title == "":
                        self.title = f"{self.file_name}:{self.row_name}"
            elif self.start_with(parameter, "C"):
                try:
                    self.col = int(parameter[1:])
                    logging.debug(f"Column: {self.col}")
                except ValueError:
                    logging.error(f"Failed to convert {parameter[1:]} to int")
            elif self.start_with(parameter, "YMIN"):
                try:
                    self.ymin = float(parameter[4:])
                    logging.debug(f"Y min: {self.ymin}")
                except ValueError:
                    logging.error(f"Failed to convert {parameter[4:]} to float")
            elif self.start_with(parameter, "YMAX"):
                try:
                    self.ymax = float(parameter[4:])
                    logging.debug(f"Y max: {self.ymax}")
                except ValueError:
                    logging.error(f"Failed to convert {parameter[4:]} to float")
            elif self.start_with(parameter, "GRID"):
                self.grid = True
                logging.debug(f"Grid: {self.grid}")


# @dataclass
class AvgFilter:
    """Simple moving average filter"""

    def __init__(self, len: int = 10, moving_average: bool = False) -> None:
        self.len: int = len
        self.data: list[int] = []
        self.moving_average: bool = moving_average

    def update(self, new_val: float) -> float:
        """Update filter with new value"""

        if self.len == 1:
            return new_val

        self.data.append(new_val)
        # self.moving_average = True

        if self.moving_average is True:
            if len(self.data) > self.len:
                self.data.pop(0)
            return sum(self.data) / len(self.data)
        else:
            if len(self.data) >= self.len:
                val = sum(self.data) / len(self.data)
                self.data.clear()
                return val


class SimplePlot:
    def __init__(
        self,
        parent=None,
        params: PlotParam = None,
        source: Any = None,
    ):
        self.params = params

        if self.params.x_axis_time is True:
            self.widget = pg.PlotWidget(
                parent=parent,
                background="default",
                plotItem=None,
                title=self.params.title,
                axisItems={"bottom": pg.DateAxisItem()},
            )
        else:
            self.widget = pg.PlotWidget(
                parent=parent,
                background="default",
                plotItem=None,
                title=self.params.title,
            )

        self.source = source
        self.last_value = 0
        self.filter = AvgFilter(
            self.params.average,
            self.params.moving_average
        )

        if self.params is not None:
            if self.params.ymin is not None and self.params.ymax is not None:
                self.widget.setYRange(self.params.ymin, self.params.ymax)

        if self.params.x_axis_time is True:
            #self.params.average
            if self.params.moving_average is True:
                mul = self.params.interval
            else:
                mul = self.params.interval*self.params.average

            self.x = [time.time() - (self.params.datapoints - i)*mul/1000 for i in range(self.params.datapoints)]
            #self.x = [time.time() - (self.params.datapoints - i) for i in range(self.params.datapoints)]
        else:
            self.x = list(range(self.params.datapoints))

        self.y = [0 for _ in range(self.params.datapoints)]

        pen = pg.mkPen(color=self.params.plot_color, width=1)
        self.line = self.widget.plot(self.x, self.y, pen=pen)

        if self.params.grid is True:
            self.widget.showGrid(x=False, y=True)

        self.widget.getAxis("bottom").setPen(axis_pen)
        self.widget.getAxis("left").setPen(axis_pen)

        # self.getAxis("right").setPen(plot_pen)
        # self.getAxis("top").setPen(plot_pen)

        # self.setLabel("left", "aaa")
        # self.setLabel("bottom", "bbb")

    def update_plot(self, new_val: float) -> None:
        """Update plot with new value"""

        if new_val is None:
            self.last_value = None
            return

        val = self.filter.update(new_val)

        self.last_value = val

        if val is None:
            return

        # remove "left" value
        self.x = self.x[1:]
        self.y = self.y[1:]

        if self.params.x_axis_time is True:
            self.x.append(time.time())
        else:
            self.x.append(self.x[-1] + 1)

        self.y.append(val)
        self.line.setData(self.x, self.y)

    def get_widgets(self) -> list[pg.PlotWidget]:
        """Return plot widgets"""
        return [self.widget]


class DerivedPlot(SimplePlot):

    def __init__(self, parent=None, params=None, source=None):
        super().__init__(parent, params)
        self.source = source
        self.params = params

    def update(self) -> None:
        """Update plot with new value"""
        self.update_plot(self.source.last_value)


class Plots:
    def __init__(self):
        self.plots: list[XPlot] = []

    def add_plot(self, plot: XPlot) -> None:
        self.plots.append(plot)

    def update(self) -> None:
        for plot in self.plots:
            plot.update()

    def get_widgets(self) -> list[pg.PlotWidget]:
        """Return plot widgets"""
        widgets = []
        for plot in self.plots:
            widgets.extend(plot.get_widgets())
        return widgets

    def __iter__(self):
        self.index = 0
        return self

    def __next__(self) -> XPlot:
        if self.index >= len(self.plots):
            raise StopIteration
        self.index += 1
        return self.plots[self.index - 1]


class PidPlot(SimplePlot):
    """Plot CPU usage for a specific process"""

    def __init__(
        self,
        params: PlotParam = None,
    ):
        self.params = params
        super().__init__(
            params=params,
        )

    def update(self) -> None:
        """Update plot with new value"""

        if psutil.pid_exists(self.params.pid) is False:
            logging.error(f"PID {self.params.pid} does not exist")
            return

        self.update_plot(self.params.process.cpu_percent())

    def __str__(self) -> str:
        return f"PidPlot {self.params.pid}"


class CPUPlot(SimplePlot):
    """Plot CPU usage"""

    def __init__(
        self,
        params: PlotParam,
    ):
        super().__init__(
            params=params
        )

    def update(self, value=None) -> None:
        """Update plot with new value"""

        if value is None:
            self.update_plot(psutil.cpu_percent(percpu=False))
        else:
            self.update_plot(value)

    def __str__(self) -> str:
        return "CPUPlot"


class CPUPlotI:
    """Plot CPU usage for each core"""

    def __init__(
        self,
        params: PlotParam,
    ):
        self.plots = []
        for x in range(psutil.cpu_count()):
            new_param = copy(params)
            new_param.title = f"CPU{x} (%)"
            self.plots.append(
                CPUPlot(
                    params=new_param
                )
            )

    def update(self) -> None:
        """Update plot with new value"""
        cpu_state = psutil.cpu_percent(percpu=True)

        for i, plot in enumerate(self.plots):
            plot.update(cpu_state[i])

    def get_widgets(self) -> list[pg.PlotWidget]:
        """Return plot widgets"""
        plot_list = []
        for plot in self.plots:
            plot_list.extend(plot.get_widgets())
        return plot_list

    def __str__(self) -> str:
        return "CPUPlot"


class SysPlot(SimplePlot):
    """Plot data from file in /proc or /sys"""

    def __init__(
        self,
        params: PlotParam
    ) -> None:
        super().__init__(
            params=params
        )
        # print(f"Sysplot: {params.file_name} {params.row} {params.col}")
        self.col = params.col
        self.file_name = params.file_name

        if type(params.row) is int:
            self.row = params.row
            return

        if params.row.isnumeric():
            self.row = int(params.row)
        else:
            with open(self.file_name) as file:
                lines = [line for line in file]

            for i, line in enumerate(lines):
                if params.row in line:
                    break
            self.row = i + 1

    def get_line_val(self, row: int, col: int) -> float:
        """Get value from a specific row and column in a file"""

        try:
            with open(self.file_name) as file:
                lines = file.readlines()
        except FileNotFoundError:
            logging.error(f"File not found: {self.file_name}")
            return 0

        line = lines[row - 1].replace("\n", "")
        columns = line.split(" ")

        # Remove empty strings
        columns = [column for column in columns if column != ""]

        try:
            column = columns[col - 1]
            val = float(column) / self.params.divider
            logging.debug(f"{self.file_name} {val} {row} {col}")
        except IndexError:
            logging.error(f'Failed to get column {col} in line: "{line}" {columns}')
            return 0
        except ValueError:  # If value is not a number
            logging.error(f'Failed to convert "{column}" to value, in line: "{line}"')
            val = 0

        return val

    def update(self):
        """Update plot with new value"""

        val = self.get_line_val(self.row, self.col)
        self.update_plot(val)

    def __str__(self) -> str:
        return f"Sysplot {self.file_name} {self.row} {self.col}"


class FilePlot(SimplePlot):
    """Plot data from a ordinary file"""

    def __init__(self, params: PlotParam) -> None:
        super().__init__(
            params=params
        )
        self.params = params
        #logging.debug(f"FilePlot: {params.file_name} {params.col}")
        try:
            self.file = open(self.params.file_name, "r")
        except FileNotFoundError:
            logging.error(f"File not found: {self.params.file_name}")
            self.file = None

    def get_line_val(self, col: int) -> float:
        """Get value from a specific row and column in a file"""

        if self.file is None:
            print("File is None")
            return None

        try:
            line = self.file.readline()
        except FileNotFoundError:
            logging.error(f"File not found: {self.params.file_name}")
            return None
        except ValueError:
            return None

        if line == "":
            self.file.close()
            return None

        columns = line.split(" ")
        # Remove empty strings
        columns = [column for column in columns if column != ""]
        try:
            column = columns[col - 1]
            val = float(column) / self.params.divider
            logging.debug(f"{self.params.file_name} {val} {self.params.col}")
            #print("Value:", val)
        except IndexError:
            logging.error(f'Failed to get column {col} in line: "{line}" {columns}')
            val = 0
            print("IndexError")
        except ValueError:  # If value is not a number
            logging.error(f'Failed to convert "{column}" to value, in line: "{line}"')
            val = None
            print("ValueError")
        return val

    def update(self) -> None:
        """Update plot with new value"""

        val = self.get_line_val(self.params.col)
        self.update_plot(val)

    def __str__(self) -> str:
        return f"FilePlot {self.params.file_name} {self.params.row} {self.params.col}"


class ProcessPlot(SimplePlot):
    """Plot data from a process"""

    def __init__(
        self,
        file_name: str = "",
        cmd: str = "",
        row: str = "1",
        col: int = 0,
        row_name: str = "",
        title: str = "",
        datapoints: int = 1000,
        divider=1,
        average=1,
    ) -> None:
        super().__init__(
            title=title, datapoints=datapoints, average=average, divider=divider
        )

        self.col = col
        self.file_name = file_name
        self.cmd = cmd

        self.process = QtCore.QProcess()

    def update(self):
        """Update plot with new value"""

        self.process.start(self.cmd)
        self.process.waitForFinished()
        data = self.process.readAll()

        lines = str(data, "utf-8").split("\n")
        line = lines[self.row - 1]
        columns = re.split(r" |\t", line)
        # remove empty strings
        columns = [x for x in columns if x != ""]
        column = columns[self.col - 1]

        try:
            val = float(column) / self.divider
            logging.debug(f"Exec: {self.cmd}  {self.col} {self.row}")
        except ValueError:
            logging.error(f'Failed to convert "{column}" to value, in line: "{line}"')
            val = 0

        self.update_plot(val)

    def __str__(self) -> str:
        return f"FilePlot {self.file_name} {self.row} {self.col}"


class MainWindow(QtWidgets.QMainWindow):
    """Main window for fplot"""

    def __init__(
        self,
        plotwidgets: Plots,
        title: str = "",
        columns: int = 1,
        interval: int = 1000,
    ):
        super(MainWindow, self).__init__()

        self.plots = plotwidgets
        self.setWindowTitle(title)
        self.setWindowIcon(QIcon(App.ICON))
        centralWidget = QtWidgets.QWidget(self)
        self.setCentralWidget(centralWidget)
        self.vbox = QtWidgets.QVBoxLayout(centralWidget)
        self.vbox.setContentsMargins(0, 0, 0, 0)

        # hbox = QtWidgets.QHBoxLayout(centralWidget)
        hbox = QtWidgets.QHBoxLayout()
        hbox.setSpacing(0)
        hbox.setContentsMargins(0, 0, 0, 0)
        self.vbox.addLayout(hbox)

        # button = QPushButton("Quit", self)
        # self.vbox.addWidget(button)
        # self.graphWidget.setBackground('w')

        vboxes: list[QtWidgets.QHBoxLayout] = []
        for i in range(columns):
            vbox = QtWidgets.QVBoxLayout()
            vbox.setSpacing(0)
            hbox.addLayout(vbox)
            vboxes.append(vbox)

        plotwidgets = self.plots.get_widgets()
        per = math.ceil(len(plotwidgets) / columns)
        for i, widget in enumerate(plotwidgets):
            vboxes[i // per].addWidget(widget)

        self.timer = QtCore.QTimer()
        self.timer.setInterval(interval)
        self.timer.timeout.connect(self.update_plot_data)
        self.timer.start()

    def update_plot_data(self):
        self.plots.update()


class FplotConfig():
    """Parse JSON config file"""

    def __init__(
        self,
        conf_file: str,
        title: str = "",
        datapoints: int = 1000,
        columns: int = 1
    ) -> None:

        self.conf_file = conf_file
        self.title = title
        self.datapoints = datapoints
        self.divider = 1
        self.conf = {}

        with self.conf_file as infile:
            self.conf = json.load(infile)

        self.title = self.get_param("title", title)
        self.datapoints = self.get_param("datapoints", datapoints)
        self.columns = self.get_param("columns", columns)
        self.average = self.get_param("average", 1)
        self.interval = self.get_param("interval", Def.INTERVAL)

        self.params = []
        for plotd in self.conf["plots"]:
            self.params.append(
                PlotParam(
                    param_string="",
                    file_name=self.get_param_conf(plotd, "source", ""),
                    cmd=self.get_param_conf(plotd, "cmd", ""),
                    title=self.get_param_conf(plotd, "title", ""),
                    divider=self.get_param_conf(plotd, "divider", self.divider),
                    row=self.get_param_conf(plotd, "row", 1),
                    col=self.get_param_conf(plotd, "col", 1),
                    ymin=self.get_param_conf(plotd, "ymin", None),
                    ymax=self.get_param_conf(plotd, "ymax", None),
                    grid=self.get_param_conf(plotd, "grid", False),
                    average=self.get_param_conf(plotd, "average", 1),
                    moving_average=self.get_param_conf(plotd, "moving_average", False),
                    datapoints=self.get_param_conf(plotd, "datapoints", self.datapoints),
                    plot_color=self.get_param_conf(plotd, "color", "Red"),
                    interval=self.interval
                )
            )
            #print(f"Params: {params}")

    def get_param(self, param: str, default: Any) -> Any:
        """Get parameter from config file"""

        if param in self.conf:
            return self.conf[param]

        return default

    def get_param_conf(self, conf: dict, param: str, default: Any) -> Any:
        """Get parameter from config file"""

        if param in conf:
            return conf[param]

        return default


class CustomAction(Action):
    """Custom action for argparse"""

    def __init__(self, option_strings, dest, **kwargs):
        super().__init__(option_strings, dest, **kwargs)

    def __call__(self, parser, namespace, values, option_string=None):
        logging.debug(f"Dest: {self.dest} Values: {values}")
        dest = getattr(namespace, self.dest)
        plot_args_list.append((self.dest, values))
        setattr(namespace, self.dest, dest)


epilog = """

src:params#"My title"

Plot parameters:
  src     Filename or pid number of process to plot
  Dxx     Set divisor, with wich to divide the datavalues
  Pxx     Set number of datapoints in plot
  Axx     Add an averaging filter, XX = points
  Mxx     Add a moving average filter, XX = points
  Rxx     Row in file
  Cxx     Column in file
  YMIN    Minimum Y axis value
  YMAX    Maximum Y axis value
  #TITLE  Title text of plot


Examples:\n

> fplot --plot /sys/class/hwmon/hwmon0/temp1_input:d1000#"CPU Temp"
> fplot --plot /proc/meminfo:r2:c2:d1024#"Free Memory (MB)"
> fplot --plotpid 1234#"Process CPU time (%)"
> fplot --plotcpu#"Total CPU (%)"
"""


def main() -> None:
    logging_format = "[%(levelname)s] %(lineno)d %(funcName)s() : %(message)s"
    #logging.basicConfig(format=logging_format, level=logging.DEBUG)
    parser = ArgumentParser(
        prog=App.NAME,
        description=App.DESCRIPTION,
        epilog=epilog,
        add_help=True,
        formatter_class=RawDescriptionHelpFormatter,
    )
    parser.add_argument(
        "--plot",
        action=CustomAction,
        default=[],
        help="Add plot from file in /proc or /sys",
        metavar="",
    )
    parser.add_argument(
        "--plotf",
        action=CustomAction,
        default=[],
        help="Add plot from a regular file, reading sequentially",
        metavar="",
    )
    parser.add_argument(
        "--plotpid",
        action=CustomAction,
        default=[],
        help="Add plot for a specific PID",
        metavar="PID",
    )
    parser.add_argument(
        "--plotcpu",
        action=CustomAction,
        default="x",
        help="Add plot for total CPU usage",
    )
    if GPIO is not False:
        parser.add_argument(
            "--plotgpio",
            action=CustomAction,
            default="x",
            help="Add plot for GPIO pin state (high/low) (only for Raspberry Pi)",
            metavar="PIN",
        )
    # parser.add_argument(
    #     "--plotcpui",
    #     action="store_true",
    #     default=[],
    #     help="Add CPU usage plot, all individual cores",
    # )
    parser.add_argument(
        "--plotd",
        action=CustomAction,
        default=[],
        help="Add a derived plot.",
        metavar="",
    )
    parser.add_argument(
        "--columns",
        action="store",
        default=Def.COLUMNS,
        type=int,
        help="Set number of columns",
        metavar="N",
    )
    parser.add_argument(
        "--grid",
        action="store_true",
        default=False,
        help="Show grid",
    )
    parser.add_argument(
        "--datapoints",
        default=Def.DATAPOINTS,
        type=int,
        help="Set default nr of datapoints",
        metavar="N",
    )
    parser.add_argument(
        "--average",
        default=1,
        type=int,
        help="Set moving average filter",
        metavar="N",
    )
    parser.add_argument(
        "--interval",
        default=Def.INTERVAL,
        type=int,
        help="Set update interval (ms)",
        metavar="N",
    )
    parser.add_argument(
        "--title",
        default="",
        type=str,
        help="Set window title"
    )
    parser.add_argument(
        "--conf",
        action="append",
        default=[],
        type=FileType("r"),
        help="Fplot config file",
        metavar="FILE",
    )
    parser.add_argument(
        "--debug",
        action="store_true",
        default=False,
        help="Print debug messages"
    )
    parser.add_argument(
        "--colors",
        action="store_true",
        default=False,
        help="Print available colors"
    )
    parser.add_argument(
        "--version",
        action="version",
        version=f"{App.NAME} {App.VERSION}",
        help="Print version information",
    )
    args = parser.parse_args()

    if args.debug:
        logging.basicConfig(format=logging_format, level=logging.DEBUG)
    else:
        logging.basicConfig(format=logging_format)

    app = QtWidgets.QApplication(sys.argv)

    plot_list = Plots()

    # Handle fplot config files
    for config_file in args.conf:

        config = FplotConfig(
            conf_file=config_file,
            title=args.title,
            datapoints=args.datapoints,
            columns=args.columns,
        )

        for params in config.params:

            #if params.file_name != "":
            if contains_only(".", params.file_name):

                try:
                    src_idx = params.file_name.count('.')
                    source = plot_list.plots[0 - src_idx]
                except IndexError:
                    logging.error(f"Failed to get source plot for derived plot: {params.file_name}")
                    return
                sparams = copy(source.params)
                sparams.average = params.average
                sparams.moving_average = params.moving_average
                sparams.plot_color = params.plot_color
                sparams.title = params.title
                #params.parse(param_string)
                print(sparams)

                plot_list.add_plot(
                    DerivedPlot(params=sparams, source=source)
                )
                continue

            if params.file_name == "cpu":
                # cpu_plot = CPUPlot(
                #     title=params.title,
                #     datapoints=params.datapoints,
                #     average=params.average,
                # )
                #plot_list.add_plot(cpu_plot)
                params.ymin = 0
                params.ymax = 100
                params.title = "CPU"
                plot_list.add_plot(
                    CPUPlot(params=params)
                )   

                continue

            if params.file_name == "cpui":
                cpu_plot = CPUPlotI(
                    datapoints=params.datapoints,
                    average=params.average,
                )
                plot_list.add_plot(cpu_plot)
                continue

            file_plot = SysPlot(params=params)
            logging.debug(file_plot)
            plot_list.add_plot(file_plot)

    for params in args.plotpid:
        params.ymin = 0
        params.ymax = 100

        try:
            params.pid = int(params.file_name)
        except ValueError:
            logging.error(f"Invalid PID: {params.file_name}")
            continue
        params.process = psutil.Process(params.pid)

        params.title = f'pid {params.pid} "{params.process.name()}" (%)'
        if psutil.pid_exists(params.pid) is False:
            logging.error(f"PID {params.pid} does not exist")
            continue
        plot_list.add_plot(
            PidPlot(params=params)
        )

    # for proc in args.process:
    #     process = QtCore.QProcess()
    #     process.start(proc)
    #     pid_plot = PidPlot(
    #         pid=process.processId(), datapoints=args.datapoints, average=args.average
    #     )
    #     plots.append(pid_plot)
    #     file_plot = FilePlot(
    #         file_name=f"/proc/{process.processId()}/stat",
    #         title="Memory usage",
    #         divider=1024 * 1024,
    #         # datapoints=datapoints,
    #         row="1",
    #         col=23,
    #         # average=average,
    #     )
    #     plots.append(file_plot)

    for plot_arg in plot_args_list:
        dest, param_string = plot_arg
        print(f"Plot args: {dest=} : {param_string=}")
        params = PlotParam(
            param_string=param_string,
            datapoints=args.datapoints,
            average=args.average,
            grid=args.grid,
            interval=args.interval
        )

        if dest == "plot":

            if params.file_name.upper() == "CPU":
                params.title = "CPU (%)"
                params.ymin = 0
                params.ymax = 100
                plot_list.add_plot(
                    CPUPlot(params=params)
                )
                continue

            plot_list.add_plot(SysPlot(params=params))

        elif dest == "plotf":
            params.x_axis_time = False
            plot_list.add_plot(FilePlot(params=params))

        elif dest == "plotd":
            try:
                src_idx = params.file_name.count('.')
                source = plot_list.plots[0 - src_idx]
            except IndexError:
                logging.error(f"Failed to get source plot for derived plot: {params.file_name}")
                return

            params = copy(source.params)
            params.parse(param_string)
            plot = DerivedPlot(params=params, source=source)
            plot_list.add_plot(plot)

        elif dest == "plotcpu":
            params.title = "CPU (%)"
            params.ymin = 0
            params.ymax = 100
            plot_list.add_plot(
                CPUPlot(params=params)
            )

    if args.colors:
        print_html_colors()
        return 0

    if len(plot_list.plots) == 0:
        parser.print_help()
        return 1

    for plotarg in plot_list.plots:
        logging.debug(plotarg)

    if "config" in locals():
        main = MainWindow(
            plot_list,
            title=config.title,
            columns=config.columns,
            interval=config.interval,
        )
    else:
        main = MainWindow(
            plot_list, title=args.title, columns=args.columns, interval=args.interval
        )
    main.show()
    sys.exit(app.exec())


if __name__ == "__main__":
    try:
        main()
        sys.exit(0)
    except KeyboardInterrupt as e:  # Ctrl-C
        raise e
    except SystemExit as e:  # sys.exit()
        raise e
    except Exception as e:
        logging.error("UNEXPECTED EXCEPTION")
        logging.error(str(e))
        traceback.print_exc()
        os._exit(1)
